/**
 * REDSCORES DATA ADAPTER
 * Focus: XPath/Regex extraction from hybrid JSON/HTML responses.
 */

import { CONFIG } from '../config';

export const redScoresAdapter = {
    /**
     * Fetches the live match list from the backend proxy.
     * Falls back to Vite proxy if backend is unavailable.
     */
    fetchLiveMatches: async () => {
        // Try backend proxy first (bypasses CORS)
        const backendUrl = 'http://localhost:3001/api/redscores/live';
        const viteProxyUrl = '/api-redscores/homepage/?refreshHomepage=true&filter_main=Live';

        try {
            console.log('[REDSCORES] Trying backend proxy...');
            const response = await fetch(backendUrl);

            if (response.ok) {
                const data = await response.json();

                if (data && data.error) {
                    console.warn('[REDSCORES] Backend proxy error:', data.error);
                    // Fall through to Vite proxy
                } else if (data && data.events) {
                    return redScoresAdapter.processResponse(data);
                } else {
                    console.warn('[REDSCORES] Unexpected backend proxy response:', data);
                }
            }
        } catch (backendError) {
            console.log('[REDSCORES] Backend proxy unavailable, trying Vite proxy...');
        }

        // Fallback to Vite proxy
        try {
            const response = await fetch(viteProxyUrl, {
                headers: {
                    'Accept': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                }
            });
            const text = await response.text();
            if (!text) {
                console.warn('[REDSCORES] Empty response received from proxy');
                return [];
            }

            let data;
            try {
                data = JSON.parse(text);
            } catch (pErr) {
                console.error('[REDSCORES] JSON Parse Error. Raw response snippet:', text.substring(0, 200));
                return [];
            }

            if (!data.events || data.events.length === 0) {
                console.log('[REDSCORES] No live matches found');
                return [];
            }

            const normalizedMatches = [];
            const byIdKeys = Object.keys(data.byId || {});
            const matchKeys = byIdKeys.filter(k => k.startsWith('xmatch_'));

            if (matchKeys.length === 0) {
                console.log('[REDSCORES] No live xmatch keys found in byId');
                return [];
            }

            for (const key of matchKeys) {
                const eventId = key.replace('xmatch_', '');
                const html = data.byId[key];
                if (!html) continue;

                try {
                    normalizedMatches.push(redScoresAdapter.parseDashboardRow(eventId, html));
                } catch (err) {
                    console.error(`[REDSCORES] Parse error for ${eventId}:`, err);
                }
            }
            return normalizedMatches;
        } catch (error) {
            console.error('RedScores fetchLiveMatches Error:', error);
            return [];
        }
    },

    /**
     * Processes the response from the backend proxy.
     */
    processResponse: (data) => {
        if (!data.events || data.events.length === 0) {
            console.log('[REDSCORES] No live matches found');
            return [];
        }

        const normalizedMatches = [];
        const byIdKeys = Object.keys(data.byId || {});
        const matchKeys = byIdKeys.filter(k => k.startsWith('xmatch_'));

        if (matchKeys.length === 0) {
            console.log('[REDSCORES] No live xmatch keys found in byId');
            return [];
        }

        for (const key of matchKeys) {
            const eventId = key.replace('xmatch_', '');
            const html = data.byId[key];
            if (!html) continue;

            try {
                normalizedMatches.push(redScoresAdapter.parseDashboardRow(eventId, html));
            } catch (err) {
                console.error(`[REDSCORES] Parse error for ${eventId}:`, err);
            }
        }

        console.log(`[REDSCORES] Successfully parsed ${normalizedMatches.length} matches`);
        return normalizedMatches;
    },

    /**
     * Parses a single match row from the dashboard.
     */
    parseDashboardRow: (id, html) => {
        // Basic Regex Extraction (Validated against raw HTML)
        const teamMatches = [...html.matchAll(/class="\s*team"\s*>([^<]+)/g)];
        const homeTeam = teamMatches[0]?.[1]?.trim() || 'Home';
        const awayTeam = teamMatches[1]?.[1]?.trim() || 'Away';

        const scoreMatch = html.match(/class="colored-value colored-value--score[^>]*>([\d\s-]+)/);
        const score = scoreMatch ? scoreMatch[1].trim() : '0 - 0';
        const [hScore, aScore] = score.split('-').map(s => parseInt(s.trim()) || 0);

        const minuteMatch = html.match(/class="color-red font-bold">(\d+)/);
        const minute = minuteMatch ? minuteMatch[1] : '0';

        // Stats Extraction (Using mobile icons for stability)
        const sog = html.match(/stats_shots_on_target[^]*?<span>([\d-]+)/)?.[1] || '0-0';
        const corners = html.match(/stats_corners[^]*?<span>([\d-]+)/)?.[1] || '0-0';
        const totalShots = html.match(/stats_total_shots[^]*?<span>([\d-]+)/)?.[1] || '0-0';
        const dangerousAttacks = html.match(/stats_dangerous_attacks[^]*?<span>([\d-]+)/)?.[1] || '0-0';

        // Likelihood %
        const likelihood = html.match(/bg-red-light font-12">(\d+)/)?.[1] || 0;

        return {
            id,
            homeTeam,
            awayTeam,
            leagueName: html.match(/class="tournament-name[^>]*>([^<]+)/)?.[1]?.trim() || 'League',
            score: { home: hScore, away: aScore },
            minute: minute.includes("'") ? minute : `${minute}'`,
            stats: {
                shotsOnGoal: {
                    home: parseInt(sog.split('-')[0]),
                    away: parseInt(sog.split('-')[1])
                },
                corners: {
                    home: parseInt(corners.split('-')[0]),
                    away: parseInt(corners.split('-')[1])
                },
                totalShots: {
                    home: parseInt(totalShots.split('-')[0]) || 0,
                    away: parseInt(totalShots.split('-')[1]) || 0
                },
                dangerousAttacks: {
                    home: parseInt(dangerousAttacks.split('-')[0]) || 0,
                    away: parseInt(dangerousAttacks.split('-')[1]) || 0
                },
                internalProbability: parseInt(likelihood) || 0
            },
            source: 'RedScores'
        };
    },

    /**
     * Fetches advanced details for a specific match (xG, Possession).
     */
    fetchMatchDetails: async (eventId) => {
        // Note: eventId here is the numeric ID
        // However, RedScores detail URLs often use slugs. 
        // We'll need to check if the numeric ID works directly or if we need the slug.
        // Dashboard link: <a href="/match/team-a-team-b/ID" 
        const url = `/api-redscores/match/${eventId}?refreshMatch=true`;
        try {
            const response = await fetch(url);
            const html = await response.text();

            // xG Extraction
            const xgLeft = html.match(/progress-bar__value_left[^>]*>([\d.]+)/)?.[1] || 0;
            const xgRight = html.match(/progress-bar__value_right[^>]*>([\d.]+)/)?.[1] || 0;

            // Possession
            const posLeft = html.match(/progress-value-left[^>]*>(\d+)%/)?.[1] || 50;
            const posRight = html.match(/progress-right[^>]*>(\d+)%/)?.[1] || 50;

            return {
                xg: { home: parseFloat(xgLeft), away: parseFloat(xgRight) },
                possession: { home: parseInt(posLeft), away: parseInt(posRight) }
            };
        } catch (error) {
            console.error(`[REDSCORES] Detail Fetch Error for ${eventId}:`, error);
            return null;
        }
    }
};
